import { mkdir, readdir, writeFile, rm } from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

function toCamelCase(kebab) {
  return kebab
    .split('-')
    .filter(Boolean)
    .map((part, i) => (i === 0 ? part : part.charAt(0).toUpperCase() + part.slice(1)))
    .join('');
}

const specsDir = path.resolve('openapi-specs'); // <root>/openapi-specs (json files live here)
const outModulesDir = path.resolve(specsDir, 'src/modules'); // <root>/openapi-specs/src/modules

const entries = await readdir(specsDir, { withFileTypes: true });

const modules = entries
  .filter((e) => e.isFile())
  .map((e) => e.name)
  .filter((name) => name.endsWith('.openapi.json'))
  .map((name) => {
    const module = name.slice(0, -'.openapi.json'.length); // subpath name may contain '-'
    const exportName = toCamelCase(module); // root index name, camelCase
    return { module, exportName, file: name };
  })
  .sort((a, b) => a.module.localeCompare(b.module));

if (modules.length === 0) {
  throw new Error(`No *.openapi.json files found in ${specsDir}. Expected <module>.openapi.json`);
}

// enforce safe subpath names (recommended)
for (const m of modules) {
  if (m.module.includes('/') || m.module.includes('\\')) {
    throw new Error(`Invalid module name "${m.module}" (must not contain / or \\)`);
  }
}

// clean old generated entrypoints
await mkdir(outModulesDir, { recursive: true });
for (const dirent of await readdir(outModulesDir, { withFileTypes: true })) {
  if (dirent.isFile() && dirent.name.endsWith('.ts')) {
    await rm(path.join(outModulesDir, dirent.name));
  }
}

// generate one module per spec
for (const m of modules) {
  const ts = `/* AUTO-GENERATED by scripts/${path.basename(fileURLToPath(import.meta.url))}
 * Exports default JSON object for: ${m.file}
 * Do not edit by hand.
 */

import { readFileSync } from "node:fs";
import path from "node:path";
import type { OpenAPIV3 } from "openapi-types";
import { findPackageRoot } from "../runtime/find-package-root";

// With tsup shims enabled, __dirname works in both ESM and CJS outputs.
// dist/modules/* sits next to dist/specs/*
// __dirname is available in CJS and via tsup --shims in ESM
const pkgRoot = findPackageRoot(__dirname);

// Your published layout includes dist/specs/*
const jsonPath = path.join(pkgRoot, "dist", "specs", ${JSON.stringify(m.file)});

const spec = JSON.parse(readFileSync(jsonPath, "utf8")) as OpenAPIV3.Document;
export default spec;
`;
  await writeFile(path.join(outModulesDir, `${m.module}.ts`), ts, 'utf8');
}

console.log(`Generated ${modules.length} entrypoints in ${path.relative(process.cwd(), outModulesDir)}`);

const indexOutFile = path.resolve(specsDir, 'src/index.ts');

const indexLines = modules.map((m) => `export { default as ${m.exportName} } from "./modules/${m.module}";`).join('\n');

const indexTs = `/* AUTO-GENERATED by scripts/${path.basename(fileURLToPath(import.meta.url))}
 * Root index: named exports for each spec module
 * Do not edit by hand.
 */

${indexLines}
`;

await writeFile(indexOutFile, indexTs, 'utf8');
console.log(`Generated root index: ${path.relative(process.cwd(), indexOutFile)}`);
