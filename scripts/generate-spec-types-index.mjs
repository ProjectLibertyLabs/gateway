import { readdir, writeFile } from 'node:fs/promises';
import path from 'node:path';

function toPascalCase(kebab) {
  return kebab
    .split('-')
    .filter(Boolean)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
}

function isValidIdentifier(name) {
  return /^[A-Za-z_$][A-Za-z0-9_$]*$/.test(name);
}

const typesDir = path.resolve('openapi-specs/dist/types');
const outFile = path.join(typesDir, 'index.d.ts');

const entries = await readdir(typesDir, { withFileTypes: true });

const dtsFiles = entries
  .filter((e) => e.isFile())
  .map((e) => e.name)
  .filter((name) => name.endsWith('.d.ts'))
  .filter((name) => name !== 'index.d.ts')
  .sort((a, b) => a.localeCompare(b));

if (dtsFiles.length === 0) {
  throw new Error(`No .d.ts files found in ${typesDir} (expected <module>.d.ts).`);
}

const modules = dtsFiles.map((f) => {
  const module = f.replace(/\.d\.ts$/, '');
  const exportName = toPascalCase(module);
  return { module, exportName, file: f };
}); // kebab-case module names

// Detect collisions in PascalCase module prefixes
const pascal = modules.map((m) => m.exportName);
const dupPrefixes = pascal.filter((p, i, arr) => arr.indexOf(p) !== i);
if (dupPrefixes.length) {
  throw new Error(`Type prefix collision(s) after PascalCase normalization: ${[...new Set(dupPrefixes)].join(', ')}`);
}
for (const p of pascal) {
  if (!isValidIdentifier(p)) {
    throw new Error(`Invalid generated prefix "${p}" from module name.`);
  }
}

/**
 * What symbols do we want to alias?
 * Put the exact exported type names from openapi-client-axios typegen here.
 *
 * Common ones are: Client, Components, Paths, Operations
 * (Adjust to match your actual generated output.)
 */
const SYMBOLS = ['Client', 'Components', 'Paths', 'OperationMethods', 'PathsDictionary'];

// Build aliased exports like:
// export type { Client as AccountClient, Components as AccountComponents } from "./account";
const aliasLines = modules.map((m) => {
  const mappings = SYMBOLS.map((sym) => `${sym} as ${m.exportName}${sym}`).join(', ');
  return `export type { ${mappings} } from "./${m.module}";`;
});

// Also provide a string union of modules, and a mapping type for convenience.
const mapLines = modules
  .map((m) => {
    return `  ${m.exportName}: { ${SYMBOLS.map((s) => `${s}: ${m.exportName}${s}`).join('; ')} };`;
  })
  .join('\n');

const content = `/* AUTO-GENERATED by scripts/generate-types-index.mjs
 * Do not edit by hand.
 */

${aliasLines.join('\n')}

export type ModuleName = ${modules.map((m) => JSON.stringify(m.exportName)).join(' | ')};

export type TypesByModule = {
${mapLines}
};
`;

await writeFile(outFile, content, 'utf8');
console.log(`Generated ${path.relative(process.cwd(), outFile)} with ${modules.length} modules.`);
